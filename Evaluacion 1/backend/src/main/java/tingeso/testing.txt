package tingeso.karting.config;
import org.modelmapper.ModelMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ModelMapperConfig {
    @Bean
    public ModelMapper modelMapper() {
        return new ModelMapper();
    }
}

package tingeso.karting.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
            .allowedOrigins(
                "http://localhost:5173",
                "https://tingeso.solarworks.cl",
                "http://frontend:5173",
                "http://karting-frontend:5173"
                           )
            .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
            .allowedHeaders("*")
            .exposedHeaders("Authorization")
            .allowCredentials(true)
            .maxAge(3600);
    }
}package tingeso.karting.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import tingeso.karting.DTO.PriceConfigDto;
import tingeso.karting.services.PriceConfigService;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/admin")
@RequiredArgsConstructor
public class AdminController {
    private final PriceConfigService priceConfigService;

    @GetMapping("/prices")
    public ResponseEntity<Map<String, BigDecimal>> getPrices() {
        return ResponseEntity.ok(priceConfigService.getAllPrices());
    }

    @PostMapping("/prices")
    public ResponseEntity<Map<String, BigDecimal>> updatePrices(@RequestBody PriceConfigDto priceConfigDto) {
        Map<String, BigDecimal> prices = priceConfigDto.getPrices();
        for (Map.Entry<String, BigDecimal> entry : prices.entrySet()) {
            priceConfigService.setPrice(entry.getKey(), entry.getValue());
        }
        return ResponseEntity.ok(priceConfigService.getAllPrices());
    }

    @PostMapping("/price/{key}")
    public ResponseEntity<Map<String, Object>> updateSinglePrice(
        @PathVariable String key,
        @RequestBody Map<String, BigDecimal> requestBody
                                                                ) {
        BigDecimal newPrice = requestBody.get("price");
        if (newPrice == null) {
            return ResponseEntity.badRequest().body(Map.of("error", "Price value is required"));
        }

        priceConfigService.setPrice(key, newPrice);

        Map<String, Object> response = new HashMap<>();
        response.put("key", key);
        response.put("price", priceConfigService.getPrice(key));
        response.put("updated", true);

        return ResponseEntity.ok(response);
    }
}package tingeso.karting.controller;

import lombok.RequiredArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;
import tingeso.karting.DTO.ComprobanteResponseDto;
import tingeso.karting.entities.ComprobanteEntity;
import tingeso.karting.repositories.ComprobanteRepository;
import tingeso.karting.services.ComprobanteService;
import tingeso.karting.services.PdfService;

import java.util.List;

@RestController
@RequestMapping("/api/comprobantes")
@RequiredArgsConstructor
public class ComprobanteController {
    private final ComprobanteService comprobanteService;
    private final ModelMapper modelMapper;
    private final ComprobanteRepository comprobanteRepository;
    private final PdfService pdfService;

    @GetMapping("/{id}")
    public ResponseEntity<ComprobanteResponseDto> getComprobante(@PathVariable Long id) {
        ComprobanteEntity comprobante = comprobanteRepository.findById(id)
            .orElseThrow(() -> new ResponseStatusException(
                HttpStatus.NOT_FOUND, "Comprobante no encontrado"));

        return ResponseEntity.ok(modelMapper.map(comprobante, ComprobanteResponseDto.class));
    }

    @PostMapping("/enviar/{id}")
    public ResponseEntity<String> enviarComprobante(@PathVariable Long id) {
        comprobanteService.enviarComprobantePorEmail(id);
        return ResponseEntity.ok("Comprobante enviado correctamente");
    }
    @GetMapping("/{id}/pdf")
    public ResponseEntity<byte[]> descargarComprobantePdf(@PathVariable Long id) {
        ComprobanteEntity comprobante = comprobanteRepository.findById(id)
            .orElseThrow(() -> new ResponseStatusException(
                HttpStatus.NOT_FOUND, "Comprobante no encontrado"));

        byte[] pdfBytes = pdfService.generarPdf(comprobante.getContenido());

        // Configurar los headers para la descarga
        HttpHeaders headers = new HttpHeaders();
        headers.add(HttpHeaders.CONTENT_DISPOSITION,
                    "attachment; filename=comprobante-" + comprobante.getCodigoReserva() + ".pdf");
        headers.setContentType(MediaType.APPLICATION_PDF);

        return new ResponseEntity<>(pdfBytes, headers, HttpStatus.OK);
    }
    @GetMapping("/reserva/{reservaId}")
    public ResponseEntity<ComprobanteResponseDto> getComprobanteByReservaId(@PathVariable Long reservaId) {
        List<ComprobanteEntity> comprobantes = comprobanteRepository.findByReservaId(reservaId);

        if (comprobantes.isEmpty()) {
            throw new ResponseStatusException(
                HttpStatus.NOT_FOUND, "Comprobante no encontrado para esta reserva");
        }

        // Return the first receipt (should be unique for a reservation)
        return ResponseEntity.ok(modelMapper.map(comprobantes.get(0), ComprobanteResponseDto.class));
    }
}package tingeso.karting.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import tingeso.karting.DTO.ReportResponseDto;
import tingeso.karting.services.ReportService;

import java.time.OffsetDateTime;

@RestController
@RequestMapping("/api/reports")
@RequiredArgsConstructor
public class ReportController {

    private final ReportService reportService;

    @GetMapping("/revenue-by-laps")
    public ResponseEntity<ReportResponseDto> getRevenueByLapsReport(
        @RequestParam("startDate") String startDate,
        @RequestParam("endDate") String endDate) {

        OffsetDateTime start = OffsetDateTime.parse(startDate);
        OffsetDateTime end = OffsetDateTime.parse(endDate);
        ReportResponseDto report = reportService.getLapsByRevenueReport(start, end);

        return ResponseEntity.ok(report);
    }

    @GetMapping("/revenue-by-people")
    public ResponseEntity<ReportResponseDto> getRevenueByPeopleReport(
        @RequestParam("startDate") String startDate,
        @RequestParam("endDate") String endDate) {

        OffsetDateTime start = OffsetDateTime.parse(startDate);
        OffsetDateTime end = OffsetDateTime.parse(endDate);
        ReportResponseDto report = reportService.getPeopleByRevenueReport(start, end);

        return ResponseEntity.ok(report);
    }
}package tingeso.karting.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import tingeso.karting.DTO.KartAvailabilityResponseDto;
import tingeso.karting.DTO.PricingResponseDto;
import tingeso.karting.DTO.ReservaRequestDto;
import tingeso.karting.DTO.ReservaResponseDto;
import tingeso.karting.services.ReservaService;

import java.time.OffsetDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/reservations")
@RequiredArgsConstructor
public class ReservaController {
    private final ReservaService service;

    @PostMapping("/check")
    public ResponseEntity<PricingResponseDto> checkAvailability(@RequestBody ReservaRequestDto req) {
        System.out.print("tiempo respuesta");
        System.out.print(req.getStartTime());
        System.out.print(req.getEndTime());

        PricingResponseDto pricing = service.checkAvailability(req);
        return ResponseEntity.ok(pricing);
    }

    @PostMapping
    public ResponseEntity<ReservaResponseDto> createReservation(
        @RequestBody ReservaRequestDto req
                                                               ) {
        ReservaResponseDto created = service.createReservation(req);
        return new ResponseEntity<>(created, HttpStatus.CREATED);
    }

    @GetMapping
    public ResponseEntity<List<ReservaResponseDto>> getReservations(
        @RequestParam("startDate") String startDate,
        @RequestParam("endDate")   String endDate) {
        OffsetDateTime from = OffsetDateTime.parse(startDate);
        OffsetDateTime to   = OffsetDateTime.parse(endDate);
        List<ReservaResponseDto> list = service.getReservationsBetweenDates(from, to);
        return ResponseEntity.ok(list);
    }
    @GetMapping("/availability")
    public ResponseEntity<KartAvailabilityResponseDto> checkKartAvailability(
        @RequestParam("startTime") String startTime,
        @RequestParam("endTime") String endTime) {

        System.out.println("Received availability check request:");
        System.out.println("Start time: " + startTime);
        System.out.println("End time: " + endTime);

        OffsetDateTime start = OffsetDateTime.parse(startTime);
        OffsetDateTime end = OffsetDateTime.parse(endTime);
        KartAvailabilityResponseDto availability = service.getKartAvailability(start, end);

        System.out.println("Availability response: " + availability);
        return ResponseEntity.ok(availability);
    }
    @PostMapping("/{id}/cancel")
    public ResponseEntity<ReservaResponseDto> cancelReservation(@PathVariable Long id) {
        ReservaResponseDto cancelled = service.cancelReservation(id);
        return ResponseEntity.ok(cancelled);
    }
}package tingeso.karting.DTO;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AvailabilityRequestDto {
    private OffsetDateTime startTime;
    private OffsetDateTime endTime;
    private int numKarts;
    private int duration; //minutos
}
package tingeso.karting.DTO;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AvailabilityResponseDto {
    private boolean ok;
    private List<ConflictDto> conflicts;
}
package tingeso.karting.DTO;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ComprobanteResponseDto {
    private Long id;
    private String codigoReserva;
    private OffsetDateTime fechaEmision;
    private Boolean enviado;
    private Long reservaId;
}package tingeso.karting.DTO;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ConflictDto {
    private String kartId;
    private OffsetDateTime start;
    private OffsetDateTime end;
}
package tingeso.karting.DTO;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GuestDto {
    private String name;
    private String email;
}
package tingeso.karting.DTO;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class KartAvailabilityResponseDto {
    private OffsetDateTime time;
    private int totalKarts;
    private int availableKarts;
    private List<String> availableKartIds;
}package tingeso.karting.DTO;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.Map;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PriceConfigDto {
    private Map<String, BigDecimal> prices;
}
package tingeso.karting.DTO;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PricingRequestDto {
    private OffsetDateTime startTime;
    private Integer laps;       // opcinal num vueltas
    private Integer duration;   // opcional num minutos
    private int numPeople;
    private int monthlyVisits;  // visitas del cliente en el mes
    private boolean birthday;   // si hay cumpleañero en la reserva
}package tingeso.karting.DTO;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PricingResponseDto {
    private BigDecimal baseRate;
    private BigDecimal groupDiscount;
    private BigDecimal frequencyDiscount;
    private BigDecimal birthdayDiscount;
    private BigDecimal tax;
    private BigDecimal totalAmount;
}
package tingeso.karting.DTO;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReportEntryDto {
    private String category;
    private int count;
    private BigDecimal totalRevenue;
}package tingeso.karting.DTO;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReportResponseDto {
    private String reportTitle;
    private List<ReportEntryDto> entries;
}package tingeso.karting.DTO;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservaRequestDto {
    private String responsibleName;
    private String responsibleEmail;
    private OffsetDateTime startTime;
    private OffsetDateTime endTime;
    private Integer laps;
    private Integer duration;
    private int numPeople;
    private int monthlyVisits;
    private boolean birthday;
    private List<GuestDto> guests;
}package tingeso.karting.DTO;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.OffsetDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservaResponseDto {
    private Long id;
    private String responsibleName;
    private String responsibleEmail;
    private OffsetDateTime startTime;
    private OffsetDateTime endTime;
    private List<String> kartIds;
    private List<GuestDto> guests;
    private int numPeople;
    private BigDecimal baseRate;
    private BigDecimal groupDiscount;
    private BigDecimal frequencyDiscount;
    private BigDecimal birthdayDiscount;
    private BigDecimal tax;
    private BigDecimal totalAmount;
    private String status;
}package tingeso.karting.entities;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;

@Entity
@Data
@Table(name = "comprobante")
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ComprobanteEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String codigoReserva;

    @OneToOne
    @JoinColumn(name = "reserva_id")
    private ReservaEntity reserva;

    @Column(nullable = false)
    private OffsetDateTime fechaEmision;

    @Column(columnDefinition = "TEXT")
    private String contenido;
    @Column(nullable = false)
    private Boolean enviado;

    @Column
    private OffsetDateTime fechaEnvio;
}
package tingeso.karting.entities;

import jakarta.persistence.Embeddable;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Embeddable
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GuestEmbeddable {
    private String name;
    private String email;
}package tingeso.karting.entities;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;
import java.time.OffsetDateTime;
import java.util.List;

@Entity
@Table(name = "reserva")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservaEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ElementCollection
    @CollectionTable(name = "reserva_karts",
                     joinColumns = @JoinColumn(name = "reserva_id"))
    @Column(name = "kart_id")
    private List<String> kartIds;

    @Column(nullable = false, columnDefinition = "TIMESTAMP WITH TIME ZONE")
    private OffsetDateTime startTime;

    @Column(nullable = false, columnDefinition = "TIMESTAMP WITH TIME ZONE")
    private OffsetDateTime endTime;

    private Integer laps;
    private Integer duration;

    @Column(nullable = false)
    private Integer numPeople;

    @Column(name = "responsible_name", nullable = false)
    private String responsibleName;

    @Column(name = "responsible_email", nullable = false)
    private String responsibleEmail;

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "reserva_guests",
                     joinColumns = @JoinColumn(name = "reserva_id"))
    private List<GuestEmbeddable> guests;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private ReservaStatus status;

    @Column(nullable = false)
    private BigDecimal totalPrice;

    private BigDecimal discountGroup;
    private BigDecimal discountFreq;
    private BigDecimal discountBirthday;
}
package tingeso.karting.entities;

public enum ReservaStatus {
    PENDING,
    CONFIRMED,
    CANCELLED
}
package tingeso.karting;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class KartingApplication {
	@RequestMapping("/api/me")
	public String home() {
	    return "Hola soy " + System.getenv("HOSTNAME");
	}

	public static void main(String[] args) {
		SpringApplication.run(KartingApplication.class, args);
	}

}
package tingeso.karting.repositories;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import tingeso.karting.entities.ComprobanteEntity;

import java.util.List;

@Repository
public interface ComprobanteRepository extends JpaRepository<ComprobanteEntity, Long> {
    List<ComprobanteEntity> findByReservaId(Long reservaId);
}package tingeso.karting.repositories;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import tingeso.karting.entities.ReservaEntity;
import tingeso.karting.entities.ReservaStatus;

import java.time.OffsetDateTime;
import java.util.List;

@Repository
public interface ReservaRepository extends JpaRepository<ReservaEntity, Long> {

    List<ReservaEntity> findByStatus(ReservaStatus status);
    List<ReservaEntity> findByStartTimeLessThanEqualAndEndTimeGreaterThanEqual(
        OffsetDateTime end, OffsetDateTime start);
    List<ReservaEntity> findByStartTimeBetween(OffsetDateTime from, OffsetDateTime to);

}
package tingeso.karting.services;

import jakarta.transaction.Transactional;
import lombok.AllArgsConstructor;
import lombok.RequiredArgsConstructor;
import org.springframework.boot.context.event.ApplicationReadyEvent;

import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Service;
import tingeso.karting.DTO.AvailabilityRequestDto;
import tingeso.karting.DTO.AvailabilityResponseDto;
import tingeso.karting.DTO.ConflictDto;
import tingeso.karting.entities.ReservaEntity;
import tingeso.karting.entities.ReservaStatus;
import tingeso.karting.repositories.ReservaRepository;

import java.beans.Transient;
import java.time.OffsetDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class AvailabilityService {
    private final ReservaRepository reservaRepository;
    private final KartService kartService;


    private final Map<String, NavigableSet<Interval>> calendar = new ConcurrentHashMap<>();

    @EventListener(ApplicationReadyEvent.class)
    @Transactional
    public void initAfterStartup() {
        System.out.println("=== Inicializando servicio de disponibilidad ===");

        calendar.clear();

        kartService.getAllKartIds().forEach(kartId -> {
            System.out.println("Registrando kart ID: " + kartId);
            calendar.put(kartId, new ConcurrentSkipListSet<>(
                Comparator.comparing(Interval::getStart)
                    .thenComparing(Interval::getEnd)
            ));
        });

        initCalendar();
    }

    private void initCalendar() {
        try {
            long totalReservas = reservaRepository.count();
            System.out.println("Total de reservas en la base de datos: " + totalReservas);

            List<ReservaEntity> activeReservations = new ArrayList<>();
            activeReservations.addAll(reservaRepository.findByStatus(ReservaStatus.CONFIRMED));
            activeReservations.addAll(reservaRepository.findByStatus(ReservaStatus.PENDING));

            System.out.println("Cargando " + activeReservations.size() + " reservas activas");

            for (ReservaEntity reservation : activeReservations) {
                if (reservation.getKartIds() != null && !reservation.getKartIds().isEmpty()) {
                    for (String kartId : reservation.getKartIds()) {
                        NavigableSet<Interval> intervals = calendar.get(kartId);
                        if (intervals != null) {
                            Interval interval = new Interval(reservation.getStartTime(), reservation.getEndTime());
                            boolean added = intervals.add(interval);
                            System.out.println("Kart " + kartId + " - Intervalo agregado: " + added +
                                               " (" + reservation.getStartTime() + " - " + reservation.getEndTime() + ")");
                        } else {
                            System.out.println("ERROR: Kart no encontrado: " + kartId);
                        }
                    }
                }
            }

            // Verificación final
            verifyCalendarState();

        } catch (Exception e) {
            System.err.println("ERROR al cargar reservas: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void verifyCalendarState() {
        System.out.println("\n=== Verificando estado del calendario ===");
        int totalIntervals = 0;
        for (String kartId : calendar.keySet()) {
            NavigableSet<Interval> intervals = calendar.get(kartId);
            totalIntervals += intervals.size();
            System.out.println("Kart " + kartId + ": " + intervals.size() + " reservas");
            if (!intervals.isEmpty()) {
                System.out.println("  Intervalos: " + intervals);
            }
        }
        System.out.println("Total de intervalos registrados: " + totalIntervals);
        System.out.println("=======================================\n");
    }

    public List<String> getFreeKarts(OffsetDateTime start, OffsetDateTime end) {
        System.out.println("Getting free karts for period:");
        System.out.println("Start: " + start);
        System.out.println("End: " + end);

        List<String> freeKarts = calendar.entrySet().stream()
            .filter(e -> {
                boolean isFree = isKartFree(e.getValue(), start, end);
                System.out.println("Kart " + e.getKey() + " is free: " + isFree);
                return isFree;
            })
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());

        System.out.println("Free karts: " + freeKarts);
        return freeKarts;
    }

    public AvailabilityResponseDto checkAvail(AvailabilityRequestDto req) {
        OffsetDateTime start = req.getStartTime();
        OffsetDateTime end = req.getEndTime();

        List<String> freeKarts = getFreeKarts(start, end);
        AvailabilityResponseDto resp = new AvailabilityResponseDto();
        boolean available = freeKarts.size() >= req.getNumKarts();
        resp.setOk(available);
        if (!available) {
            List<ConflictDto> conflicts = calendar.entrySet().stream()
                .flatMap(e -> e.getValue().stream()
                             .filter(i -> i.overlaps(start, end))
                             .map(i -> new ConflictDto(e.getKey(), i.getStart(), i.getEnd()))
                        )
                .collect(Collectors.toList());
            resp.setConflicts(conflicts);
        }
        return resp;
    }

    public void removeReservation(ReservaEntity res) {
        if (res.getKartIds() != null) {
            for (String kartId : res.getKartIds()) {
                calendar.get(kartId)
                    .remove(new Interval(res.getStartTime(), res.getEndTime()));
            }
        }
    }

    private boolean isKartFree(NavigableSet<Interval> intervals, OffsetDateTime start, OffsetDateTime end) {
        System.out.println("Checking " + intervals.size() + " intervals for availability");
        for (Interval interval : intervals) {
            if (interval.overlaps(start, end)) {
                System.out.println("  - Conflicto encontrado con intervalo: " +
                                   interval.getStart() + " hasta " + interval.getEnd());
                return false;
            }
        }

        Interval query = new Interval(start, end);

        Interval floor = intervals.floor(query);
        if (floor != null && floor.overlaps(start, end)) {
            return false;
        }

        Interval ceiling = intervals.ceiling(query);
        if (ceiling != null && ceiling.overlaps(start, end)) {
            return false;
        }

        return true;
    }

    public void registerKartReservation(String kartId, OffsetDateTime start, OffsetDateTime end) {
        calendar.get(kartId).add(new Interval(start, end));
    }

    public void registerReservation(ReservaEntity res) {
        if (res.getKartIds() != null && !res.getKartIds().isEmpty()) {
            System.out.println("Registrando reserva ID: " + res.getId() + " con " + res.getKartIds().size() + " karts");
            for (String kartId : res.getKartIds()) {
                NavigableSet<Interval> intervals = calendar.get(kartId);
                if (intervals != null) {
                    System.out.println("  - Agregando intervalo para kart " + kartId);
                    intervals.add(new Interval(res.getStartTime(), res.getEndTime()));
                } else {
                    System.out.println("  - ERROR: Kart ID no encontrado: " + kartId);
                }
            }
        } else {
            System.out.println("No se pueden registrar karts para reserva ID: " + res.getId() + " - no hay karts asignados");
        }
    }

    @AllArgsConstructor
    private static class Interval implements Comparable<Interval> {
        private OffsetDateTime start;
        private OffsetDateTime end;

        public OffsetDateTime getStart() {
            return start;
        }

        public OffsetDateTime getEnd() {
            return end;
        }

        public boolean overlaps(OffsetDateTime s, OffsetDateTime e) {
            return !start.isAfter(e) && !end.isBefore(s);
        }

        @Override
        public int compareTo(Interval other) {
            int startCompare = start.compareTo(other.start);
            return startCompare != 0 ? startCompare : end.compareTo(other.end);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Interval interval = (Interval) o;
            return Objects.equals(start, interval.start) && Objects.equals(end, interval.end);
        }

        @Override
        public int hashCode() {
            return Objects.hash(start, end);
        }

        @Override
        public String toString() {
            return "Interval[" + start + " -> " + end + "]";
        }
    }
}package tingeso.karting.services;

import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;
import tingeso.karting.entities.ComprobanteEntity;
import tingeso.karting.entities.GuestEmbeddable;
import tingeso.karting.entities.ReservaEntity;
import tingeso.karting.repositories.ComprobanteRepository;
import tingeso.karting.repositories.ReservaRepository;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

@Service
@RequiredArgsConstructor
public class ComprobanteService {
    private final ReservaRepository reservaRepository;
    private final ComprobanteRepository comprobanteRepository;
    private final EmailService emailService;
    private final PdfService pdfService;

    @Transactional
    public ComprobanteEntity generarComprobante(ReservaEntity reserva) {
        String codigoReserva = "RES-" + reserva.getId() + "-" + System.currentTimeMillis();

        String contenidoHtml = generarContenidoHtml(reserva);

        // Crear la entidad de comprobante
        ComprobanteEntity comprobante = ComprobanteEntity.builder()
            .codigoReserva(codigoReserva)
            .reserva(reserva)
            .fechaEmision(OffsetDateTime.now())
            .contenido(contenidoHtml)
            .enviado(false)
            .build();

        return comprobanteRepository.save(comprobante);
    }

    @Transactional
    public void enviarComprobantePorEmail(Long comprobanteId) {
        ComprobanteEntity comprobante = comprobanteRepository.findById(comprobanteId)
            .orElseThrow(() -> new ResponseStatusException(
                HttpStatus.NOT_FOUND, "Comprobante no encontrado"));

        ReservaEntity reserva = comprobante.getReserva();

        // Generar PDF del comprobante
        byte[] pdfBytes = pdfService.generarPdf(comprobante.getContenido());

        // Enviar email al responsable
        emailService.enviarEmailConAdjunto(
            reserva.getResponsibleEmail(),
            "Comprobante de Reserva - KartingRM",
            "Adjunto encontrarás el comprobante de tu reserva en KartingRM.",
            "comprobante.pdf",
            pdfBytes
                                          );

        // Enviar email a cada invitado
        for (GuestEmbeddable guest : reserva.getGuests()) {
            if (!guest.getEmail().equals(reserva.getResponsibleEmail())) {
                emailService.enviarEmailConAdjunto(
                    guest.getEmail(),
                    "Comprobante de Reserva - KartingRM",
                    "Has sido invitado a una sesión de karting. Adjunto encontrarás el comprobante de la reserva.",
                    "comprobante.pdf",
                    pdfBytes
                                                  );
            }
        }
        comprobante.setEnviado(true);
        comprobante.setFechaEnvio(OffsetDateTime.now());
        comprobanteRepository.save(comprobante);
    }

    private String generarContenidoHtml(ReservaEntity reserva) {
        StringBuilder html = new StringBuilder();
        html.append("<html><head><style>");
        html.append("body { font-family: Arial, sans-serif; font-size: 12px; }");
        html.append("h1 { font-size: 18px; }");
        html.append("h2 { font-size: 16px; }");
        html.append("table { border-collapse: collapse; width: 100%; }");
        html.append("th, td { border: 1px solid #ddd; padding: 6px; text-align: left; font-size: 11px; }");
        html.append("th { background-color: #f2f2f2; }");
        html.append(".email-cell { word-break: break-word; }");
        html.append("</style></head><body>");

        html.append("<h1>Comprobante de Reserva - KartingRM</h1>");
        html.append("<p>Código de Reserva: " + reserva.getId() + "</p>");
        html.append("<p>Fecha de emisión: " + OffsetDateTime.now().format(
            DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm")) + "</p>");

        html.append("<h2>Información de la Reserva</h2>");
        html.append("<p>Fecha: " + reserva.getStartTime().format(
            DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm")) + "</p>");
        html.append("<p>Responsable: " + reserva.getResponsibleName() + "</p>");
        html.append("<p>Email: " + reserva.getResponsibleEmail() + "</p>");
        html.append("<p>Número de personas: " + reserva.getNumPeople() + "</p>");

        // Tabla con cabeceras ligeramente abreviadas
        html.append("<h2>Detalle de Participantes</h2>");
        html.append("<table>");
        html.append("<tr>");
        html.append("<th>Nombre</th>");
        html.append("<th class='email-cell'>Email</th>");
        html.append("<th>Tarifa</th>");
        html.append("<th>Desc. Grupo</th>");
        html.append("<th>Desc. Frec.</th>");
        html.append("<th>Desc. Cumple</th>");
        html.append("<th>IVA</th>");
        html.append("<th>Total</th>");
        html.append("</tr>");

        BigDecimal precioBaseTotal = reserva.getTotalPrice();
        BigDecimal totalDescuentos = BigDecimal.ZERO;

        if (reserva.getDiscountGroup() != null) {
            totalDescuentos = totalDescuentos.add(reserva.getDiscountGroup());
        }
        if (reserva.getDiscountFreq() != null) {
            totalDescuentos = totalDescuentos.add(reserva.getDiscountFreq());
        }
        if (reserva.getDiscountBirthday() != null) {
            totalDescuentos = totalDescuentos.add(reserva.getDiscountBirthday());
        }

        BigDecimal precioSinIva = precioBaseTotal.divide(new BigDecimal("1.19"), 2, RoundingMode.HALF_UP);
        BigDecimal totalIva = precioBaseTotal.subtract(precioSinIva);

        BigDecimal precioBaseTotalSinDescuentos = precioSinIva.add(totalDescuentos);
        BigDecimal tarifaBaseIndividual = precioBaseTotalSinDescuentos.divide(
            BigDecimal.valueOf(reserva.getNumPeople()), 2, RoundingMode.HALF_UP);

        BigDecimal descuentoGrupoIndividual = BigDecimal.ZERO;
        BigDecimal descuentoFreqIndividual = BigDecimal.ZERO;
        BigDecimal descuentoBirthdayIndividual = BigDecimal.ZERO;

        if (reserva.getDiscountGroup() != null && reserva.getDiscountGroup().compareTo(BigDecimal.ZERO) > 0) {
            descuentoGrupoIndividual = reserva.getDiscountGroup().divide(
                BigDecimal.valueOf(reserva.getNumPeople()), 2, RoundingMode.HALF_UP);
        }

        if (reserva.getDiscountFreq() != null && reserva.getDiscountFreq().compareTo(BigDecimal.ZERO) > 0) {
            descuentoFreqIndividual = reserva.getDiscountFreq().divide(
                BigDecimal.valueOf(reserva.getNumPeople()), 2, RoundingMode.HALF_UP);
        }

        if (reserva.getDiscountBirthday() != null && reserva.getDiscountBirthday().compareTo(BigDecimal.ZERO) > 0) {
            descuentoBirthdayIndividual = reserva.getDiscountBirthday().divide(
                BigDecimal.valueOf(reserva.getNumPeople()), 2, RoundingMode.HALF_UP);
        }

        BigDecimal ivaIndividual = totalIva.divide(
            BigDecimal.valueOf(reserva.getNumPeople()), 2, RoundingMode.HALF_UP);
        BigDecimal totalIndividual = precioBaseTotal.divide(
            BigDecimal.valueOf(reserva.getNumPeople()), 2, RoundingMode.HALF_UP);

        // Iterar sobre los invitados
        for (GuestEmbeddable guest : reserva.getGuests()) {
            html.append("<tr>");
            html.append("<td>" + guest.getName() + "</td>");
            html.append("<td class='email-cell'>" + guest.getEmail() + "</td>");
            html.append("<td>" + formatCurrency(tarifaBaseIndividual) + "</td>");
            html.append("<td>" + formatCurrency(descuentoGrupoIndividual) + "</td>");
            html.append("<td>" + formatCurrency(descuentoFreqIndividual) + "</td>");
            html.append("<td>" + formatCurrency(descuentoBirthdayIndividual) + "</td>");
            html.append("<td>" + formatCurrency(ivaIndividual) + "</td>");
            html.append("<td>" + formatCurrency(totalIndividual) + "</td>");
            html.append("</tr>");
        }

        html.append("</table>");

        html.append("<h2>Total a Pagar</h2>");
        html.append("<p>Subtotal: ")
            .append(formatCurrency(precioSinIva))
            .append("</p>");
        html.append("<p>IVA (19%): ")
            .append(formatCurrency(totalIva))
            .append("</p>");
        html.append("<p>Total: " + formatCurrency(reserva.getTotalPrice()) + "</p>");

        html.append("<p><strong>Este comprobante debe ser presentado el día de su visita al kartódromo.</strong></p>");

        html.append("</body></html>");

        return html.toString();
    }

    private BigDecimal calcularIVA(BigDecimal monto) {
        return monto.multiply(new BigDecimal("0.19")).divide(new BigDecimal("1.19"), 2, RoundingMode.HALF_UP);
    }

    private String formatCurrency(BigDecimal amount) {
        NumberFormat currencyFormat = NumberFormat.getCurrencyInstance(new Locale("es", "CL"));
        return currencyFormat.format(amount);
    }
}package tingeso.karting.services;

import jakarta.mail.internet.MimeMessage;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value; // Importación correcta
import org.springframework.core.io.ByteArrayResource;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class EmailService {

    private final JavaMailSender mailSender;

    @Value("${spring.mail.username}")
    private String fromEmail;

    public void enviarEmailConAdjunto(String destinatario, String asunto, String cuerpo,
                                      String nombreArchivo, byte[] archivo) {
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true);

            helper.setFrom(fromEmail);
            helper.setTo(destinatario);
            helper.setSubject(asunto);
            helper.setText(cuerpo, true); // true indica que el cuerpo es HTML

            ByteArrayResource resource = new ByteArrayResource(archivo);
            helper.addAttachment(nombreArchivo, resource);

            mailSender.send(message);
        } catch (Exception e) {
            throw new RuntimeException("Error al enviar email: " + e.getMessage());
        }
    }
}package tingeso.karting.services;

import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class KartService {

    private final List<String> kartIds = List.of(
        "K001", "K002", "K003", "K004", "K005",
        "K006", "K007", "K008", "K009", "K010",
        "K011", "K012", "K013", "K014", "K015");

    public List<String> getAllKartIds() {
        return kartIds;
    }
}package tingeso.karting.services;

import com.openhtmltopdf.pdfboxout.PdfRendererBuilder;
import org.springframework.stereotype.Service;

import java.io.ByteArrayOutputStream;

@Service
public class PdfService {

    public byte[] generarPdf(String contenidoHtml) {
        try {
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

            PdfRendererBuilder builder = new PdfRendererBuilder();
            builder.withHtmlContent(contenidoHtml, null);
            builder.toStream(outputStream);
            builder.run();

            return outputStream.toByteArray();
        } catch (Exception e) {
            throw new RuntimeException("Error generando PDF: " + e.getMessage());
        }
    }
}package tingeso.karting.services;

import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class PriceConfigService {
    private final ConcurrentHashMap<String, BigDecimal> priceConfig = new ConcurrentHashMap<>();

    public PriceConfigService() {
        priceConfig.put("VUELTAS_10_PRECIO", BigDecimal.valueOf(15000));
        priceConfig.put("VUELTAS_15_PRECIO", BigDecimal.valueOf(20000));
        priceConfig.put("VUELTAS_20_PRECIO", BigDecimal.valueOf(25000));
        priceConfig.put("DESCUENTO_GRUPO_PEQUENO", BigDecimal.valueOf(10.0));
        priceConfig.put("DESCUENTO_GRUPO_MEDIANO", BigDecimal.valueOf(20.0));
        priceConfig.put("DESCUENTO_GRUPO_GRANDE", BigDecimal.valueOf(30.0));
        priceConfig.put("DESCUENTO_FRECUENCIA_BAJA", BigDecimal.valueOf(10.0));
        priceConfig.put("DESCUENTO_FRECUENCIA_MEDIA", BigDecimal.valueOf(20.0));
        priceConfig.put("DESCUENTO_FRECUENCIA_ALTA", BigDecimal.valueOf(30.0));
        priceConfig.put("DESCUENTO_CUMPLEANOS", BigDecimal.valueOf(50.0));
    }

    public BigDecimal getPrice(String key) {
        return priceConfig.getOrDefault(key, BigDecimal.ZERO);
    }

    public void setPrice(String key, BigDecimal value) {
        priceConfig.put(key, value);
    }

    public ConcurrentHashMap<String, BigDecimal> getAllPrices() {
        return new ConcurrentHashMap<>(priceConfig);
    }
}package tingeso.karting.services;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;
import tingeso.karting.DTO.PricingRequestDto;
import tingeso.karting.DTO.PricingResponseDto;

import java.math.BigDecimal;
import java.math.RoundingMode;

@Service
public class PricingService {
    private static final BigDecimal IVA = BigDecimal.valueOf(0.19);

    private final PriceConfigService priceConfigService;

    @Autowired
    public PricingService(PriceConfigService priceConfigService) {
        this.priceConfigService = priceConfigService;
    }

    public PricingResponseDto calculatePrice(PricingRequestDto request) {
        BigDecimal baseRate = determineBaseRate(request);

        BigDecimal groupDiscount = baseRate.multiply(
            BigDecimal.valueOf(groupDiscountRate(request.getNumPeople())));

        BigDecimal freqDiscount = baseRate.multiply(
            BigDecimal.valueOf(frequencyDiscountRate(request.getMonthlyVisits())));

        BigDecimal birthdayDiscount = calculateBirthdayDiscount(request, baseRate);

        BigDecimal totalDiscount = groupDiscount.add(freqDiscount).add(birthdayDiscount);
        BigDecimal netPrice = baseRate.subtract(totalDiscount);

        BigDecimal ivaAmount = netPrice.multiply(IVA);
        BigDecimal totalPrice = netPrice.add(ivaAmount);

        return PricingResponseDto.builder()
            .baseRate(baseRate)
            .groupDiscount(groupDiscount)
            .frequencyDiscount(freqDiscount)
            .birthdayDiscount(birthdayDiscount)
            .tax(ivaAmount)
            .totalAmount(totalPrice)
            .build();
    }

    private BigDecimal calculateBirthdayDiscount(PricingRequestDto request, BigDecimal baseRate) {
        int numPeople = request.getNumPeople();

        if (numPeople < 3 || !request.isBirthday()) {
            return BigDecimal.ZERO;
        }
        BigDecimal pricePerPerson = baseRate.divide(BigDecimal.valueOf(numPeople), 2, RoundingMode.HALF_UP);
        BigDecimal discountRate = priceConfigService.getPrice("DESCUENTO_CUMPLEANOS")
            .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP);

        BigDecimal discountAmount;

        if (numPeople >= 3 && numPeople <= 5) {
            discountAmount = pricePerPerson.multiply(discountRate);
        } else if (numPeople >= 6 && numPeople <= 10) {
            discountAmount = pricePerPerson.multiply(discountRate).multiply(BigDecimal.valueOf(2));
        } else {
            discountAmount = pricePerPerson.multiply(discountRate).multiply(BigDecimal.valueOf(2));
        }

        return discountAmount;
    }

    private BigDecimal determineBaseRate(PricingRequestDto request) {
        if (request.getLaps() != null) {
            switch (request.getLaps()) {
                case 10: return priceConfigService.getPrice("VUELTAS_10_PRECIO");
                case 15: return priceConfigService.getPrice("VUELTAS_15_PRECIO");
                case 20: return priceConfigService.getPrice("VUELTAS_20_PRECIO");
                default:   throw new ResponseStatusException(
                    HttpStatus.BAD_REQUEST,
                    "Número de vueltas inválido: " + request.getLaps()
                );
            }
        }

        int duration = request.getDuration();
        if (duration <= 30) return priceConfigService.getPrice("VUELTAS_10_PRECIO");
        if (duration <= 35) return priceConfigService.getPrice("VUELTAS_15_PRECIO");
        if (duration <= 40) return priceConfigService.getPrice("VUELTAS_20_PRECIO");
        throw new IllegalArgumentException("duración no soportada: " + duration);
    }

    private double groupDiscountRate(int numPeople) {
        if (numPeople <= 2) return 0.0;
        if (numPeople <= 5) return priceConfigService.getPrice("DESCUENTO_GRUPO_PEQUENO")
            .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP)
            .doubleValue();
        if (numPeople <= 10) return priceConfigService.getPrice("DESCUENTO_GRUPO_MEDIANO")
            .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP)
            .doubleValue();
        return priceConfigService.getPrice("DESCUENTO_GRUPO_GRANDE")
            .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP)
            .doubleValue();
    }

    private double frequencyDiscountRate(int visitsPerMonth) {
        if (visitsPerMonth >= 7) return priceConfigService.getPrice("DESCUENTO_FRECUENCIA_ALTA")
            .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP)
            .doubleValue();
        if (visitsPerMonth >= 5) return priceConfigService.getPrice("DESCUENTO_FRECUENCIA_MEDIA")
            .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP)
            .doubleValue();
        if (visitsPerMonth >= 2) return priceConfigService.getPrice("DESCUENTO_FRECUENCIA_BAJA")
            .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP)
            .doubleValue();
        return 0.0;
    }

    private double birthdayDiscountRate(int numPeople) {
        if (numPeople < 3) return 0.0;

        BigDecimal descuentoBase = priceConfigService.getPrice("DESCUENTO_CUMPLEANOS")
            .divide(BigDecimal.valueOf(100), 4, RoundingMode.HALF_UP);

        BigDecimal descuento = descuentoBase;
        if (numPeople >= 11) {
            descuento = descuento.multiply(BigDecimal.valueOf(2));
        }

        return descuento.divide(BigDecimal.valueOf(numPeople), 4, RoundingMode.HALF_UP).doubleValue();
    }
}package tingeso.karting.services;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import tingeso.karting.DTO.ReportEntryDto;
import tingeso.karting.DTO.ReportResponseDto;
import tingeso.karting.entities.ReservaEntity;
import tingeso.karting.entities.ReservaStatus;
import tingeso.karting.repositories.ReservaRepository;

import java.math.BigDecimal;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ReportService {

    private final ReservaRepository reservaRepository;

    public ReportResponseDto getLapsByRevenueReport(OffsetDateTime startDate, OffsetDateTime endDate) {
        List<ReservaEntity> allReservations = reservaRepository.findByStartTimeBetween(startDate, endDate);
        List<ReservaEntity> reservations = allReservations.stream()
            .filter(r -> r.getStatus() == ReservaStatus.CONFIRMED)
            .collect(Collectors.toList());
        Map<Integer, List<ReservaEntity>> reservationsByLaps = new HashMap<>();
        for (ReservaEntity reservation : reservations) {
            Integer laps = reservation.getLaps();
            if (laps == null) {
                // Si no hay vueltas especificadas, usar la duración para estimar
                if (reservation.getDuration() != null) {
                    if (reservation.getDuration() <= 30) laps = 10;
                    else if (reservation.getDuration() <= 35) laps = 15;
                    else laps = 20;
                } else {
                    continue;
                }
            }

            reservationsByLaps.computeIfAbsent(laps, k -> new ArrayList<>()).add(reservation);
        }

        // Calculate revenue for each category
        List<ReportEntryDto> entries = new ArrayList<>();
        for (Map.Entry<Integer, List<ReservaEntity>> entry : reservationsByLaps.entrySet()) {
            BigDecimal totalRevenue = BigDecimal.ZERO;
            for (ReservaEntity reservation : entry.getValue()) {
                totalRevenue = totalRevenue.add(reservation.getTotalPrice());
            }

            entries.add(ReportEntryDto.builder()
                            .category(entry.getKey() + " vueltas")
                            .count(entry.getValue().size())
                            .totalRevenue(totalRevenue)
                            .build());
        }

        return ReportResponseDto.builder()
            .reportTitle("Ingresos por Número de Vueltas")
            .entries(entries)
            .build();
    }

    public ReportResponseDto getPeopleByRevenueReport(OffsetDateTime startDate, OffsetDateTime endDate) {
        List<ReservaEntity> allReservations = reservaRepository.findByStartTimeBetween(startDate, endDate);
        List<ReservaEntity> reservations = allReservations.stream()
            .filter(r -> r.getStatus() == ReservaStatus.CONFIRMED)
            .collect(Collectors.toList());

        Map<String, List<ReservaEntity>> reservationsByPeopleCategory = new HashMap<>();
        reservationsByPeopleCategory.put("1-2 personas", new ArrayList<>());
        reservationsByPeopleCategory.put("3-5 personas", new ArrayList<>());
        reservationsByPeopleCategory.put("6-10 personas", new ArrayList<>());
        reservationsByPeopleCategory.put("11-15 personas", new ArrayList<>());
        for (ReservaEntity reservation : reservations) {
            int numPeople = reservation.getNumPeople();
            String category;

            if (numPeople <= 2) category = "1-2 personas";
            else if (numPeople <= 5) category = "3-5 personas";
            else if (numPeople <= 10) category = "6-10 personas";
            else category = "11-15 personas";

            reservationsByPeopleCategory.get(category).add(reservation);
        }

        List<ReportEntryDto> entries = new ArrayList<>();
        for (Map.Entry<String, List<ReservaEntity>> entry : reservationsByPeopleCategory.entrySet()) {
            BigDecimal totalRevenue = BigDecimal.ZERO;
            for (ReservaEntity reservation : entry.getValue()) {
                totalRevenue = totalRevenue.add(reservation.getTotalPrice());
            }

            entries.add(ReportEntryDto.builder()
                            .category(entry.getKey())
                            .count(entry.getValue().size())
                            .totalRevenue(totalRevenue)
                            .build());
        }

        return ReportResponseDto.builder()
            .reportTitle("Ingresos por Número de Personas")
            .entries(entries)
            .build();
    }
}package tingeso.karting.services;


import lombok.RequiredArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;
import tingeso.karting.DTO.*;
import tingeso.karting.entities.ComprobanteEntity;
import tingeso.karting.entities.GuestEmbeddable;
import tingeso.karting.entities.ReservaEntity;
import tingeso.karting.entities.ReservaStatus;
import tingeso.karting.repositories.ReservaRepository;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ReservaService {
    private final AvailabilityService availabilityService;
    private final PricingService pricingService;
    private final ReservaRepository reservaRepository;
    private final ModelMapper modelMapper;
    private final KartService kartService;
    private final ComprobanteService comprobanteService;
    public PricingResponseDto checkAvailability(ReservaRequestDto req) {
        AvailabilityRequestDto aReq = AvailabilityRequestDto.builder()
            .startTime(req.getStartTime())
            .endTime(req.getEndTime())
            .numKarts(req.getNumPeople())
            .build();
        AvailabilityResponseDto avail = availabilityService.checkAvail(aReq);
        if (!avail.isOk()) {
            throw new ResponseStatusException(
                HttpStatus.CONFLICT,
                "No hay disponibilidad para esa franja horaria"
            );
        }
        PricingRequestDto pReq = modelMapper.map(req, PricingRequestDto.class);
        return pricingService.calculatePrice(pReq);
    }

    public ReservaResponseDto createReservation(ReservaRequestDto req) {
        if (req.getGuests() == null || req.getGuests().size() != req.getNumPeople()) {
            throw new ResponseStatusException(
                HttpStatus.BAD_REQUEST,
                "La cantidad de invitados debe ser igual al número de karts");
        }

        PricingResponseDto pricing = checkAvailability(req);
        List<String> free = availabilityService.getFreeKarts(req.getStartTime(), req.getEndTime());
        if (free.size() < req.getNumPeople()) {
            throw new ResponseStatusException(HttpStatus.CONFLICT, "No hay suficientes karts libres");
        }

        List<String> assigned = free.subList(0, req.getNumPeople());
        ReservaEntity entity = ReservaEntity.builder()
            .startTime(req.getStartTime())
            .endTime(req.getEndTime())
            .kartIds(assigned)
            .laps(req.getLaps())
            .duration(req.getDuration())
            .numPeople(req.getNumPeople())
            .responsibleName(req.getResponsibleName())
            .responsibleEmail(req.getResponsibleEmail())
            .guests(req.getGuests()
                        .stream()
                        .map(g -> new GuestEmbeddable(g.getName(), g.getEmail()))
                        .collect(Collectors.toList()))
            .status(ReservaStatus.CONFIRMED)
            .totalPrice(pricing.getTotalAmount())
            .discountGroup(pricing.getGroupDiscount())
            .discountFreq(pricing.getFrequencyDiscount())
            .discountBirthday(pricing.getBirthdayDiscount())
            .build();

        ReservaEntity saved = reservaRepository.save(entity);
        System.out.println("Registrando nueva reserva ID " + saved.getId() + " en el servicio de disponibilidad");
        availabilityService.registerReservation(saved);
        ComprobanteEntity comprobante = comprobanteService.generarComprobante(saved);
        comprobanteService.enviarComprobantePorEmail(comprobante.getId());

        ReservaResponseDto resp = ReservaResponseDto.builder()
            .id(saved.getId())
            .responsibleName(saved.getResponsibleName())
            .responsibleEmail(saved.getResponsibleEmail())
            .startTime(saved.getStartTime())
            .endTime(saved.getEndTime())
            .kartIds(saved.getKartIds())
            .numPeople(saved.getNumPeople())
            .guests(req.getGuests())
            .baseRate(pricing.getBaseRate())
            .groupDiscount(pricing.getGroupDiscount())
            .frequencyDiscount(pricing.getFrequencyDiscount())
            .birthdayDiscount(pricing.getBirthdayDiscount())
            .tax(pricing.getTax())
            .totalAmount(pricing.getTotalAmount())
            .status(saved.getStatus().toString())
            .build();

        return resp;
    }

    public List<ReservaResponseDto> getReservationsBetweenDates(OffsetDateTime startDate, OffsetDateTime endDate) {
        List<ReservaEntity> entities = reservaRepository.findByStartTimeBetween(startDate, endDate);
        return entities.stream()
            .map(entity -> {
                ReservaResponseDto dto = modelMapper.map(entity, ReservaResponseDto.class);
                dto.setStatus(entity.getStatus().toString());
                dto.setTotalAmount(entity.getTotalPrice());
                dto.setBirthdayDiscount(entity.getDiscountBirthday());
                dto.setFrequencyDiscount(entity.getDiscountFreq());
                dto.setGroupDiscount(entity.getDiscountGroup());
                return dto;
            })
            .collect(Collectors.toList());
    }

    @Deprecated
    public List<ReservaResponseDto> createReservations(ReservaRequestDto req) {
        return List.of(createReservation(req));
    }

    public KartAvailabilityResponseDto getKartAvailability(OffsetDateTime startTime, OffsetDateTime endTime) {
        System.out.println("Checking availability for period:");
        System.out.println("Start: " + startTime);
        System.out.println("End: " + endTime);

        List<String> allKarts = kartService.getAllKartIds();
        int totalKarts = allKarts.size();

        System.out.println("Total karts: " + totalKarts);

        List<String> freeKarts = availabilityService.getFreeKarts(startTime, endTime);

        System.out.println("Free karts: " + freeKarts.size());
        System.out.println("Free kart IDs: " + freeKarts);

        return KartAvailabilityResponseDto.builder()
            .time(startTime)
            .totalKarts(totalKarts)
            .availableKarts(freeKarts.size())
            .build();
    }
    public ReservaResponseDto cancelReservation(Long id) {
        ReservaEntity reservation = reservaRepository.findById(id)
            .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Reserva no encontrada"));

        if (reservation.getStatus() == ReservaStatus.CANCELLED) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "La reserva ya está cancelada");
        }

        reservation.setStatus(ReservaStatus.CANCELLED);

        availabilityService.removeReservation(reservation);

        ReservaEntity updated = reservaRepository.save(reservation);

        ReservaResponseDto dto = modelMapper.map(updated, ReservaResponseDto.class);
        dto.setStatus(updated.getStatus().toString());
        dto.setTotalAmount(updated.getTotalPrice());
        dto.setBirthdayDiscount(updated.getDiscountBirthday());
        dto.setFrequencyDiscount(updated.getDiscountFreq());
        dto.setGroupDiscount(updated.getDiscountGroup());

        dto.setGuests(updated.getGuests().stream()
                          .map(g -> new GuestDto(g.getName(), g.getEmail()))
                          .collect(Collectors.toList()));

        return dto;
    }
}
